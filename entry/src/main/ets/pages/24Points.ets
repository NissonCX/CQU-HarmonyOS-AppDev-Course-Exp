import { Card } from '../model/Card';
import { Game24Logic } from '../model/Game24Logic';
import { ExpressionEvaluator } from '../utils/ExpressionEvaluator';
import { promptAction } from '@kit.ArkUI'; // å¯¼å…¥ç”¨äºæ˜¾ç¤ºå¼¹çª—çš„å·¥å…·
import { ThemeManager } from '../model/ThemeManager';
import { ThemeType, ThemeColors } from '../model/Theme';
import router from '@ohos.router';

// å®šä¹‰ç®€å•è¡¨è¾¾å¼éªŒè¯ç»“æœæ¥å£
interface SimpleEvaluationResult {
  isValid: boolean;
  value?: number;
  message?: string;
}

@Entry
@Component
struct Game24Points {
  @State cards: Card[] = [];                 // å½“å‰4å¼ ç‰Œ
  @State inputExpression: string = '';       // ç”¨æˆ·è¾“å…¥çš„è¡¨è¾¾å¼
  @State gameMessage: string = 'è¯·ä½¿ç”¨è¿™4å¼ ç‰Œçš„ç‚¹æ•°ï¼Œé€šè¿‡åŠ å‡ä¹˜é™¤è¿ç®—å¾—å‡º24';  // æ¸¸æˆæç¤ºä¿¡æ¯
  @State showMessage: boolean = true;        // æ˜¯å¦æ˜¾ç¤ºæ¶ˆæ¯
  @State isCorrect: boolean = false;         // ç­”æ¡ˆæ˜¯å¦æ­£ç¡®
  @State gameFinished: boolean = false;      // æ¸¸æˆæ˜¯å¦ç»“æŸ
  @State hasSolution: boolean = false;       // å½“å‰é¢˜ç›®æ˜¯å¦æœ‰è§£ï¼ˆä»…ç”¨äºéªŒè¯ç©å®¶åˆ¤æ–­ï¼‰
  @State playerJudgment: string = '';        // ç©å®¶å¯¹æ˜¯å¦æœ‰è§£çš„åˆ¤æ–­ ('unsolvable' | 'solved' | '')
  @State solutions: string[] = [];           // é¢˜ç›®è§£æ³•
  @State currentTime: number = 0;            // å½“å‰æ¸¸æˆæ—¶é—´ï¼ˆç§’ï¼‰
  @State showSolutions: boolean = false;     // æ˜¯å¦æ˜¾ç¤ºå‚è€ƒç­”æ¡ˆ
  private startTime: number = Date.now();    // æ¸¸æˆå¼€å§‹æ—¶é—´
  private timerId: number = -1;              // å®šæ—¶å™¨ID
  
  // ä¸»é¢˜ç›¸å…³çŠ¶æ€
  @State private currentTheme: ThemeType = ThemeManager.getInstance().getCurrentTheme();
  @State private themeColors: ThemeColors = ThemeManager.getInstance().getCurrentColors();
  
  // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–æ¸¸æˆ
  aboutToAppear(): void {
    this.startNewGame();
    
    // æ·»åŠ ä¸»é¢˜ç›‘å¬å™¨
    ThemeManager.getInstance().addThemeChangeListener((theme: ThemeType, colors: ThemeColors) => {
      this.currentTheme = theme;
      this.themeColors = colors;
    });
  }
  
  // ç»„ä»¶é”€æ¯æ—¶æ¸…é™¤å®šæ—¶å™¨
  aboutToDisappear(): void {
    if (this.timerId !== -1) {
      clearInterval(this.timerId);
      this.timerId = -1;
    }
  }
  
  // å¼€å§‹æ–°æ¸¸æˆ
  startNewGame() {
    // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
    if (this.timerId !== -1) {
      clearInterval(this.timerId);
      this.timerId = -1;
    }
    
    // é‡ç½®æ¸¸æˆæ—¶é—´
    this.startTime = Date.now();
    this.currentTime = 0;
    
    // å¯åŠ¨è®¡æ—¶å™¨
    this.timerId = setInterval(() => {
      if (!this.gameFinished) {
        this.currentTime = Math.floor((Date.now() - this.startTime) / 1000);
      }
    }, 1000);
    
    // è·å–ä¸€ä¸ªéšæœºé¢˜ç›®ï¼ˆä¸æ£€æŸ¥æ˜¯å¦æœ‰è§£ï¼‰
    this.cards = Game24Logic.dealFourCards();
    
    // æ£€æŸ¥é¢˜ç›®æ˜¯å¦æœ‰è§£ï¼ˆä»…ç”¨äºåç»­éªŒè¯ç©å®¶åˆ¤æ–­ï¼‰
    const cardNumbers = this.cards.map(card => card.getRankValue());
    this.hasSolution = Game24Logic.canMake24(cardNumbers);
    
    // è·å–æ‰€æœ‰è§£æ³•
    this.solutions = Game24Logic.getAllSolutions(cardNumbers);
    
    // é‡ç½®çŠ¶æ€
    this.inputExpression = '';
    this.gameMessage = 'è¯·ä½¿ç”¨è¿™4å¼ ç‰Œçš„ç‚¹æ•°ï¼Œé€šè¿‡åŠ å‡ä¹˜é™¤è¿ç®—å¾—å‡º24';
    this.showMessage = true;
    this.isCorrect = false;
    this.gameFinished = false;
    this.playerJudgment = '';
  }
  
  // å¤„ç†è¾“å…¥è¡¨è¾¾å¼å˜åŒ–
  private onExpressionChange(value: string): void {
    this.inputExpression = value;
  }
  
  // ç©å®¶ç‚¹å‡»æ— è§£æŒ‰é’®
  markAsUnsolvable() {
    this.playerJudgment = 'unsolvable';
    
    // æ¸…é™¤å®šæ—¶å™¨
    if (this.timerId !== -1) {
      clearInterval(this.timerId);
      this.timerId = -1;
    }
    
    // æ£€æŸ¥ç©å®¶åˆ¤æ–­æ˜¯å¦æ­£ç¡®
    if (!this.hasSolution) {
      // å½“ç©å®¶åˆ¤æ–­æ­£ç¡®ä¸”é¢˜ç›®ç¡®å®æ— è§£æ—¶ï¼Œæ˜¾ç¤ºç±»ä¼¼æ­£ç¡®ç­”æ¡ˆçš„æç¤º
      this.gameMessage = `ğŸ‰ æ­å–œï¼åˆ¤æ–­æ­£ç¡®ã€‚è¿™ç»„ç‰Œç¡®å®æ— è§£ã€‚ç”¨æ—¶: ${this.currentTime}ç§’`;
      this.isCorrect = true;
    } else {
      // å½“ç©å®¶åˆ¤æ–­é”™è¯¯æ—¶ï¼Œæ˜¾ç¤ºé¢˜ç›®çš„è§£æ³•
      const firstSolution = this.solutions.length > 0 ? this.solutions[0] : "æ— è§£æ³•";
      this.gameMessage = `âŒ åˆ¤æ–­é”™è¯¯ï¼è¿™ç»„ç‰Œå…¶å®æœ‰è§£: ${firstSolution}`;
      this.isCorrect = false;
    }
    this.showMessage = true;
    this.gameFinished = true;
  }
  
  // æäº¤ç­”æ¡ˆ - æ–°æ€è·¯å®ç°
  submitAnswer() {
    // ç©å®¶æäº¤è¡¨è¾¾å¼ï¼Œè¡¨ç¤ºè®¤ä¸ºæœ‰è§£
    this.playerJudgment = 'solved';
    
    if (!this.inputExpression) {
      this.gameMessage = 'è¯·è¾“å…¥è¡¨è¾¾å¼';
      this.showMessage = true;
      return;
    }
    
    // ä½¿ç”¨æ–°çš„è§£ææ–¹æ³•éªŒè¯è¡¨è¾¾å¼
    const result = Game24Points.parseAndEvaluate(this.inputExpression, this.cards);
    
    if (!result.isValid) {
      this.gameMessage = result.message || 'è¡¨è¾¾å¼æ— æ•ˆ';
      this.showMessage = true;
      this.isCorrect = false;
      this.gameFinished = true;
      return;
    }
    
    // æ¸…é™¤å®šæ—¶å™¨
    if (this.timerId !== -1) {
      clearInterval(this.timerId);
      this.timerId = -1;
    }
    
    if (Math.abs(result.value! - 24) < 1e-6) {
      this.gameMessage = `ğŸ‰ æ­å–œï¼ç­”æ¡ˆæ­£ç¡®ã€‚${this.inputExpression} = ${result.value} ç”¨æ—¶: ${this.currentTime}ç§’`;
      this.showMessage = true;
      this.isCorrect = true;
      this.gameFinished = true;
    } else {
      this.gameMessage = `âŒ ç­”æ¡ˆé”™è¯¯ã€‚${this.inputExpression} = ${result.value} â‰  24`;
      this.showMessage = true;
      this.isCorrect = false;
      this.gameFinished = true;
    }
  }
  
  // è§£æå¹¶è®¡ç®—ç”¨æˆ·è¾“å…¥çš„è¡¨è¾¾å¼
  static parseAndEvaluate(expression: string, cards: Card[]): SimpleEvaluationResult {
    try {
      // é¢„å¤„ç†è¡¨è¾¾å¼
      let processedExpr = expression.replace(/\s/g, ''); // ç§»é™¤ç©ºæ ¼
      
      // æ›¿æ¢ç‰¹æ®Šç¬¦å·
      processedExpr = processedExpr.replace(/Ã—/g, '*');
      processedExpr = processedExpr.replace(/Ã·/g, '/');
      processedExpr = processedExpr.replace(/âˆ’/g, '-');
      processedExpr = processedExpr.replace(/ï¹£/g, '-');
      processedExpr = processedExpr.replace(/Â·/g, '*');
      
      // æ£€æŸ¥æ˜¯å¦åŒ…å«éæ³•å­—ç¬¦
      if (!/^[\d+\-*/().]+$/.test(processedExpr)) {
        const result: SimpleEvaluationResult = { isValid: false, message: "è¡¨è¾¾å¼åŒ…å«éæ³•å­—ç¬¦" };
        return result;
      }
      
      // æ£€æŸ¥æ‹¬å·æ˜¯å¦åŒ¹é…
      if (!Game24Points.checkParentheses(processedExpr)) {
        const result: SimpleEvaluationResult = { isValid: false, message: "æ‹¬å·ä¸åŒ¹é…" };
        return result;
      }
      
      // æå–æ•°å­—
      const numbers = Game24Points.extractNumbersFromExpression(processedExpr);
      
      // æ£€æŸ¥æ˜¯å¦æ­£å¥½æœ‰4ä¸ªæ•°å­—
      if (numbers.length !== 4) {
        const result: SimpleEvaluationResult = { isValid: false, message: `è¡¨è¾¾å¼åº”åŒ…å«4ä¸ªæ•°å­—ï¼Œä½†æ‰¾åˆ°äº†${numbers.length}ä¸ª` };
        return result;
      }
      
      // æ£€æŸ¥æ•°å­—æ˜¯å¦ä¸å¡ç‰ŒåŒ¹é…
      const cardValues = cards.map(card => card.getRankValue()).sort();
      const exprNumbers = [...numbers].sort();
      
      for (let i = 0; i < 4; i++) {
        if (exprNumbers[i] !== cardValues[i]) {
          const result: SimpleEvaluationResult = { isValid: false, message: `ä½¿ç”¨çš„æ•°å­—ä¸å¡ç‰Œä¸åŒ¹é…` };
          return result;
        }
      }
      
      // è®¡ç®—è¡¨è¾¾å¼ç»“æœ
      const value = Game24Points.calculate(processedExpr);
      
      const result: SimpleEvaluationResult = { isValid: true, value: value };
      return result;
    } catch (error) {
      const result: SimpleEvaluationResult = { 
        isValid: false, 
        message: "è¡¨è¾¾å¼æ ¼å¼é”™è¯¯: " + (error instanceof Error ? error.message : String(error)) 
      };
      return result;
    }
  }
  
  // ä»è¡¨è¾¾å¼ä¸­æå–æ•°å­—
  static extractNumbersFromExpression(expression: string): number[] {
    const numbers: number[] = [];
    let i = 0;
    
    while (i < expression.length) {
      // è·³è¿‡æ“ä½œç¬¦å’Œæ‹¬å·
      if ('+-*/()'.includes(expression[i])) {
        i++;
        continue;
      }
      
      // æå–æ•°å­—
      if (/\d/.test(expression[i])) {
        let numStr = '';
        while (i < expression.length && /\d/.test(expression[i])) {
          numStr += expression[i];
          i++;
        }
        const num = parseInt(numStr, 10);
        if (num >= 1 && num <= 13) {
          numbers.push(num);
        }
      } else {
        i++;
      }
    }
    
    return numbers;
  }
  
  // è®¡ç®—è¡¨è¾¾å¼ç»“æœ - è‡ªå®šä¹‰è§£æå®ç°
  evaluateExpression(expression: string): number {
    // å…ˆéªŒè¯è¡¨è¾¾å¼æ ¼å¼
    if (!expression || typeof expression !== 'string') {
      throw new Error("æ— æ•ˆçš„è¡¨è¾¾å¼");
    }
    
    // ç¡®ä¿è¡¨è¾¾å¼åªåŒ…å«å…è®¸çš„å­—ç¬¦
    if (!/^[\d+\-*/().]+$/.test(expression)) {
      throw new Error("è¡¨è¾¾å¼åŒ…å«éæ³•å­—ç¬¦");
    }
    
    // æ£€æŸ¥æ‹¬å·æ˜¯å¦åŒ¹é…
    if (!Game24Points.checkParentheses(expression)) {
      throw new Error("æ‹¬å·ä¸åŒ¹é…");
    }
    
    // å®‰å…¨è®¡ç®—è¡¨è¾¾å¼
    return Game24Points.calculate(expression);
  }
  
  // æ£€æŸ¥æ‹¬å·æ˜¯å¦åŒ¹é…
  static checkParentheses(expression: string): boolean {
    let count: number = 0;
    for (let i: number = 0; i < expression.length; i++) {
      if (expression[i] === '(') {
        count++;
      } else if (expression[i] === ')') {
        count--;
        if (count < 0) {
          return false;
        }
      }
    }
    return count === 0;
  }
  
  // é€’å½’è®¡ç®—è¡¨è¾¾å¼
  static calculate(expr: string): number {
    // ç§»é™¤ç©ºæ ¼
    expr = expr.replace(/\s/g, '');
    
    if (expr.length === 0) {
      throw new Error("ç©ºè¡¨è¾¾å¼");
    }
    
    // å¤„ç†æ‹¬å·
    while (expr.includes('(')) {
      const lastOpenParen: number = expr.lastIndexOf('(');
      const firstCloseParenAfter: number = expr.indexOf(')', lastOpenParen);
      
      if (firstCloseParenAfter === -1) {
        throw new Error("æ‹¬å·ä¸åŒ¹é…");
      }
      
      const innerExpr: string = expr.substring(lastOpenParen + 1, firstCloseParenAfter);
      const innerResult: number = Game24Points.calculate(innerExpr);
      expr = expr.substring(0, lastOpenParen) + innerResult.toString() + expr.substring(firstCloseParenAfter + 1);
    }
    
    // å¤„ç†ä¹˜æ³•å’Œé™¤æ³•
    while (expr.includes('*') || expr.includes('/')) {
      const mulIndex: number = expr.indexOf('*');
      const divIndex: number = expr.indexOf('/');
      
      let operatorIndex: number;
      let operator: string;
      
      if (mulIndex !== -1 && (divIndex === -1 || mulIndex < divIndex)) {
        operatorIndex = mulIndex;
        operator = '*';
      } else if (divIndex !== -1) {
        operatorIndex = divIndex;
        operator = '/';
      } else {
        break;
      }
      
      // è·å–æ“ä½œç¬¦å‰çš„æ•°å­—
      let leftStart: number = operatorIndex - 1;
      while (leftStart >= 0 && (/\d/.test(expr[leftStart]) || expr[leftStart] === '.' || expr[leftStart] === '-')) {
        if (expr[leftStart] === '-' && leftStart > 0 && !'0123456789.'.includes(expr[leftStart - 1])) {
          break;
        }
        leftStart--;
      }
      leftStart++;
      
      // è·å–æ“ä½œç¬¦åçš„æ•°å­—
      let rightEnd: number = operatorIndex + 1;
      if (rightEnd < expr.length && expr[rightEnd] === '-') {
        rightEnd++;
      }
      while (rightEnd < expr.length && (/\d/.test(expr[rightEnd]) || expr[rightEnd] === '.')) {
        rightEnd++;
      }
      
      const leftNum: number = parseFloat(expr.substring(leftStart, operatorIndex));
      const rightNum: number = parseFloat(expr.substring(operatorIndex + 1, rightEnd));
      
      if (isNaN(leftNum) || isNaN(rightNum)) {
        throw new Error("æ— æ•ˆæ•°å­—");
      }
      
      let result: number;
      if (operator === '*') {
        result = leftNum * rightNum;
      } else {
        if (Math.abs(rightNum) < 1e-10) {
          throw new Error("é™¤æ•°ä¸èƒ½ä¸ºé›¶");
        }
        result = leftNum / rightNum;
      }
      
      expr = expr.substring(0, leftStart) + result.toString() + expr.substring(rightEnd);
    }
    
    // å¤„ç†åŠ æ³•å’Œå‡æ³•
    // å…ˆå¤„ç†ç¬¬ä¸€ä¸ªæ•°å­—å¯èƒ½ä¸ºè´Ÿæ•°çš„æƒ…å†µ
    let startIndex: number = 0;
    if (expr[0] === '-') {
      startIndex = 1;
    }
    
    while (expr.includes('+') || expr.indexOf('-', startIndex) !== -1) {
      const addIndex: number = expr.indexOf('+', startIndex);
      const subIndex: number = expr.indexOf('-', startIndex);
      
      let operatorIndex: number;
      let operator: string;
      
      if (addIndex !== -1 && (subIndex === -1 || addIndex < subIndex)) {
        operatorIndex = addIndex;
        operator = '+';
      } else if (subIndex !== -1 && subIndex >= startIndex) {
        operatorIndex = subIndex;
        operator = '-';
      } else {
        break;
      }
      
      // è·å–æ“ä½œç¬¦å‰çš„æ•°å­—
      let leftStart: number = operatorIndex - 1;
      while (leftStart >= 0 && (/\d/.test(expr[leftStart]) || expr[leftStart] === '.' || expr[leftStart] === '-')) {
        if (expr[leftStart] === '-' && leftStart > 0 && !'0123456789.'.includes(expr[leftStart - 1])) {
          break;
        }
        leftStart--;
      }
      leftStart++;
      
      // è·å–æ“ä½œç¬¦åçš„æ•°å­—
      let rightEnd: number = operatorIndex + 1;
      if (rightEnd < expr.length && expr[rightEnd] === '-') {
        rightEnd++;
      }
      while (rightEnd < expr.length && (/\d/.test(expr[rightEnd]) || expr[rightEnd] === '.')) {
        rightEnd++;
      }
      
      const leftNum: number = parseFloat(expr.substring(leftStart, operatorIndex));
      const rightNum: number = parseFloat(expr.substring(operatorIndex + 1, rightEnd));
      
      if (isNaN(leftNum) || isNaN(rightNum)) {
        throw new Error("æ— æ•ˆæ•°å­—");
      }
      
      let result: number;
      if (operator === '+') {
        result = leftNum + rightNum;
      } else {
        result = leftNum - rightNum;
      }
      
      expr = expr.substring(0, leftStart) + result.toString() + expr.substring(rightEnd);
    }
    
    const finalResult: number = parseFloat(expr);
    if (isNaN(finalResult)) {
      throw new Error("è®¡ç®—ç»“æœæ— æ•ˆ");
    }
    
    return finalResult;
  }
  
  // æ˜¾ç¤ºè§£æ³•å¼¹çª—
  showSolutionsDialog() {
    this.showSolutions = true;
  }
  
  // éšè—è§£æ³•
  hideSolutionsDialog() {
    this.showSolutions = false;
  }

  build() {
    Column() {
      // æ ‡é¢˜åŒºåŸŸ - å±…ä¸­å¯¹ç§°å¸ƒå±€
      Column() {
        Row() {
          // è¿”å›æŒ‰é’®
          Button('â†')
            .width(40)
            .height(40)
            .backgroundColor(this.themeColors.buttonBackground)
            .fontColor(this.themeColors.buttonText)
            .borderRadius(20)
            .border({ width: 1, color: this.themeColors.buttonBorder })
            .shadow({
              radius: 4,
              color: this.themeColors.cardShadow,
              offsetX: 1,
              offsetY: 1
            })
            .onClick(() => {
              router.back();
            })
          
          // æ ‡é¢˜åŒºåŸŸ
          Column() {
            Text('ğŸƒ 24ç‚¹æ¸¸æˆ ğŸ§®')
              .fontSize(28)
              .fontWeight(FontWeight.Bold)
              .textAlign(TextAlign.Center)
              .fontColor(this.themeColors.primaryText)

            Text('ä½¿ç”¨4å¼ ç‰Œé€šè¿‡è¿ç®—å¾—åˆ°24')
              .fontSize(14)
              .fontColor(this.themeColors.secondaryText)
              .margin({ top: 6 })
          }
          .layoutWeight(1)
          .alignItems(HorizontalAlign.Center)
          
          // å ä½ç¬¦ä¿æŒå¯¹ç§°
          Column()
            .width(40)
            .height(40)
        }
        .width('100%')
        .padding({ left: 20, right: 20 })
        .margin({ top: 20, bottom: 20 })

        // æ—¶é—´æ˜¾ç¤º - å±…ä¸­
        Row() {
          Text('â± æ—¶é—´')
            .fontSize(14)
            .fontColor(this.themeColors.secondaryText)
            .margin({ right: 8 })
          
          Text(`${this.currentTime.toString().padStart(3, '0')}s`)
            .fontSize(18)
            .fontWeight(FontWeight.Medium)
            .fontColor(this.themeColors.buttonText)
        }
        .padding({ left: 20, right: 20, top: 12, bottom: 12 })
        .backgroundColor(this.themeColors.cardBackground)
        .borderRadius(20)
        .border({ width: 1, color: this.themeColors.cardBorder })
        .shadow({
          radius: 6,
          color: this.themeColors.cardShadow,
          offsetX: 2,
          offsetY: 2
        })
        .alignSelf(ItemAlign.Center)
        .margin({ bottom: 20 })
      }
      .width('100%')
      .alignItems(HorizontalAlign.Center)

      // å¡ç‰Œæ˜¾ç¤ºåŒºåŸŸ
      Row() {
        ForEach(this.cards, (card: Card, index: number) => {
          Image($r('app.media.' + card.getResourceName()))
            .width(80)
            .height(110)
            .margin({ left: 5, right: 5 })
            .borderRadius(8)
            .shadow({
              radius: 6,
              color: '#333333',
              offsetX: 2,
              offsetY: 2
            })
        }, (item: Card) => item.getResourceName())
      }
      .margin({ top: 20, bottom: 30 })
      .alignItems(VerticalAlign.Center)
      
      // è¾“å…¥åŒºåŸŸ
      Column() {
        Text('ğŸ”¢ è¯·è¾“å…¥è¿ç®—è¡¨è¾¾å¼:')
          .fontSize(16)
          .margin({ bottom: 15 })
          .fontColor(this.themeColors.primaryText)
        
        // æç¤ºä¿¡æ¯
        Row() {
          Text(this.gameMessage)
            .fontSize(14)
            .fontColor(this.isCorrect ? this.themeColors.successColor : this.themeColors.errorColor)
            .textAlign(TextAlign.Center)
            .width('80%')
            .padding(15)
            .backgroundColor(this.themeColors.cardBackground)
            .borderRadius(12)
            .shadow({
              radius: 6,
              color: this.themeColors.cardShadow,
              offsetX: 2,
              offsetY: 2
            })
            .visibility(this.showMessage ? Visibility.Visible : Visibility.Hidden)
        }
        .width('100%')
        .justifyContent(FlexAlign.Center)
        .margin({ bottom: 20 })
        
        TextInput({ placeholder: 'ğŸ“Œ ä¾‹å¦‚: (5-1)*(6/2)', text: this.inputExpression })
          .onChange((value: string) => this.onExpressionChange(value))
          .width('80%')
          .height(50)
          .margin({ bottom: 30, top: 10 })
          .enabled(!this.gameFinished)
          .backgroundColor(this.themeColors.inputBackground)
          .borderRadius(12)
          .shadow({
            radius: 6,
            color: this.themeColors.cardShadow,
            offsetX: 2,
            offsetY: 2
          })
          .placeholderColor(this.themeColors.secondaryText)
          .fontColor(this.themeColors.inputText)
      }
      .width('100%')
      .alignItems(HorizontalAlign.Center)
      
      // å‚è€ƒç­”æ¡ˆæ˜¾ç¤ºåŒºåŸŸ
      if (this.showSolutions && this.gameFinished) {
        Column() {
          Row() {
            Text('ğŸ“‹ å‚è€ƒç­”æ¡ˆ')
              .fontSize(18)
              .fontWeight(FontWeight.Bold)
              .fontColor(this.themeColors.primaryText)
            
            Button('é€€å‡º')
              .width(60)
              .height(40)
              .fontSize(16)
              .fontColor(this.themeColors.buttonText)
              .backgroundColor(this.themeColors.buttonBackground)
              .borderRadius(20)
              .border({ width: 1, color: this.themeColors.buttonBorder })
              .onClick(() => {
                this.hideSolutionsDialog();
              })
              .margin({ left: 10 })
          }
          .width('90%')
          .justifyContent(FlexAlign.SpaceBetween)
          .alignItems(VerticalAlign.Center)
          
          Scroll() {
            Column() {
              ForEach(this.solutions, (solution: string, index: number) => {
                Row() {
                  Text(`${index + 1}. ${solution}`)
                    .fontSize(16)
                    .fontColor(this.themeColors.primaryText)
                    .textAlign(TextAlign.Start)
                    .width('100%')
                }
                .width('100%')
                .padding(10)
                .backgroundColor(this.themeColors.cardBackground)
                .borderRadius(10)
                .margin({ bottom: 10 })
              })
              
              if (this.solutions.length === 0) {
                Text('è¿™é“é¢˜æ— è§£')
                  .fontSize(16)
                  .fontColor(this.themeColors.primaryText)
                  .padding(10)
                  .backgroundColor(this.themeColors.cardBackground)
                  .borderRadius(10)
                  .width('100%')
                  .textAlign(TextAlign.Center)
              }
            }
            .width('90%')
            .padding({ top: 10, bottom: 10 })
          }
          .layoutWeight(1)
          .width('100%')
        }
        .width('100%')
        .height(300)
        .padding(20)
        .backgroundColor(this.themeColors.cardBackground)
        .borderRadius(20)
        .border({ width: 1, color: this.themeColors.cardBorder })
        .shadow({
          radius: 8,
          color: this.themeColors.cardShadow,
          offsetX: 2,
          offsetY: 2
        })
        .margin({ bottom: 20 })
      }
      
      // æŒ‰é’®åŒºåŸŸ
      Column() {
        Row({ space: 16 }) {
          Button('ğŸ”„ é‡æ–°å¼€å§‹')
            .width(150)
            .height(50)
            .fontSize(16)
            .backgroundColor(this.themeColors.buttonBackground)
            .fontColor(this.themeColors.buttonText)
            .borderRadius(14)
            .border({ width: 1, color: this.themeColors.buttonBorder })
            .shadow({
              radius: 8,
              color: this.themeColors.cardShadow,
              offsetX: 2,
              offsetY: 2
            })
            .onClick(() => {
              this.startNewGame();
              this.hideSolutionsDialog();
            })
          
          Button('â“ æ— è§£')
            .width(150)
            .height(50)
            .fontSize(16)
            .backgroundColor(this.themeColors.buttonBackground)
            .fontColor(this.themeColors.buttonText)
            .borderRadius(14)
            .border({ width: 1, color: this.themeColors.buttonBorder })
            .shadow({
              radius: 8,
              color: this.themeColors.cardShadow,
              offsetX: 2,
              offsetY: 2
            })
            .enabled(!this.gameFinished)
            .onClick(() => {
              this.markAsUnsolvable();
            })
        }
        .margin({ bottom: 15 })
        .justifyContent(FlexAlign.Center)
        
        // æŸ¥çœ‹ç­”æ¡ˆæŒ‰é’®ï¼ˆä»…åœ¨æ¸¸æˆç»“æŸåæ˜¾ç¤ºï¼‰
        if (this.gameFinished && !this.showSolutions) {
          Button('ğŸ‘€ æŸ¥çœ‹ç­”æ¡ˆ')
            .width(316)
            .height(50)
            .fontSize(16)
            .backgroundColor(this.themeColors.buttonBackground)
            .fontColor(this.themeColors.buttonText)
            .borderRadius(14)
            .border({ width: 1, color: this.themeColors.buttonBorder })
            .shadow({
              radius: 8,
              color: this.themeColors.cardShadow,
              offsetX: 2,
              offsetY: 2
            })
            .margin({ bottom: 15 })
            .onClick(() => {
              this.showSolutionsDialog();
            })
        }
      }
      .width('100%')
      .alignItems(HorizontalAlign.Center)
      .justifyContent(FlexAlign.End)
      .padding({ bottom: 30 })
      
      // åº•éƒ¨ä¿¡æ¯åŒºåŸŸ - å±…ä¸­å¸ƒå±€
      Column() {
        Text('ğŸ¯ 24ç‚¹æ¸¸æˆè€ƒéªŒä½ çš„æ•°å­¦è¿ç®—èƒ½åŠ›')
          .fontSize(12)
          .fontColor(this.themeColors.tertiaryText)
          .margin({ bottom: 6 })

        Text('ğŸ§® æ•°å­¦è¿ç®— Â· â±ï¸ é€»è¾‘æŒ‘æˆ˜')
          .fontSize(11)
          .fontColor(this.themeColors.tertiaryText)
          .margin({ bottom: 6 })

        Text('ğŸ‘¨â€ğŸ’» åˆ¶ä½œäººï¼šNisson_CX')
          .fontSize(11)
          .fontColor(this.themeColors.tertiaryText)
          .margin({ bottom: 20 })
      }
      .width('100%')
      .alignItems(HorizontalAlign.Center)
      .padding({ bottom: 20 })
    }
    .width('100%')
    .height('100%')
    .backgroundColor(this.themeColors.background)
    .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])
  }
}