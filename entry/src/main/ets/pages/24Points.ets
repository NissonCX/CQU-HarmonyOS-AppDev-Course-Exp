import { Card } from '../model/Card';
import { Game24Logic } from '../model/Game24Logic';
import { ExpressionEvaluator } from '../utils/ExpressionEvaluator';
import { promptAction } from '@kit.ArkUI'; // å¯¼å…¥ç”¨äºæ˜¾ç¤ºå¼¹çª—çš„å·¥å…·

// å®šä¹‰ç®€å•è¡¨è¾¾å¼éªŒè¯ç»“æœæ¥å£
interface SimpleEvaluationResult {
  isValid: boolean;
  value?: number;
  message?: string;
}

@Entry
@Component
struct Game24Points {
  @State cards: Card[] = [];                 // å½“å‰4å¼ ç‰Œ
  @State inputExpression: string = '';       // ç”¨æˆ·è¾“å…¥çš„è¡¨è¾¾å¼
  @State gameMessage: string = 'è¯·ä½¿ç”¨è¿™4å¼ ç‰Œçš„ç‚¹æ•°ï¼Œé€šè¿‡åŠ å‡ä¹˜é™¤è¿ç®—å¾—å‡º24';  // æ¸¸æˆæç¤ºä¿¡æ¯
  @State showMessage: boolean = true;        // æ˜¯å¦æ˜¾ç¤ºæ¶ˆæ¯
  @State isCorrect: boolean = false;         // ç­”æ¡ˆæ˜¯å¦æ­£ç¡®
  @State gameFinished: boolean = false;      // æ¸¸æˆæ˜¯å¦ç»“æŸ
  @State hasSolution: boolean = false;       // å½“å‰é¢˜ç›®æ˜¯å¦æœ‰è§£ï¼ˆä»…ç”¨äºéªŒè¯ç©å®¶åˆ¤æ–­ï¼‰
  @State playerJudgment: string = '';        // ç©å®¶å¯¹æ˜¯å¦æœ‰è§£çš„åˆ¤æ–­ ('unsolvable' | 'solved' | '')
  @State solutions: string[] = [];           // é¢˜ç›®è§£æ³•
  @State currentTime: number = 0;            // å½“å‰æ¸¸æˆæ—¶é—´ï¼ˆç§’ï¼‰
  private startTime: number = Date.now();    // æ¸¸æˆå¼€å§‹æ—¶é—´
  private timerId: number = -1;              // å®šæ—¶å™¨ID
  
  // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–æ¸¸æˆ
  aboutToAppear(): void {
    this.startNewGame();
  }
  
  // ç»„ä»¶é”€æ¯æ—¶æ¸…é™¤å®šæ—¶å™¨
  aboutToDisappear(): void {
    if (this.timerId !== -1) {
      clearInterval(this.timerId);
      this.timerId = -1;
    }
  }
  
  // å¼€å§‹æ–°æ¸¸æˆ
  startNewGame() {
    // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
    if (this.timerId !== -1) {
      clearInterval(this.timerId);
      this.timerId = -1;
    }
    
    // é‡ç½®æ¸¸æˆæ—¶é—´
    this.startTime = Date.now();
    this.currentTime = 0;
    
    // å¯åŠ¨è®¡æ—¶å™¨
    this.timerId = setInterval(() => {
      if (!this.gameFinished) {
        this.currentTime = Math.floor((Date.now() - this.startTime) / 1000);
      }
    }, 1000);
    
    // è·å–ä¸€ä¸ªéšæœºé¢˜ç›®ï¼ˆä¸æ£€æŸ¥æ˜¯å¦æœ‰è§£ï¼‰
    this.cards = Game24Logic.dealFourCards();
    
    // æ£€æŸ¥é¢˜ç›®æ˜¯å¦æœ‰è§£ï¼ˆä»…ç”¨äºåç»­éªŒè¯ç©å®¶åˆ¤æ–­ï¼‰
    const cardNumbers = this.cards.map(card => card.getRankValue());
    this.hasSolution = Game24Logic.canMake24(cardNumbers);
    
    // è·å–æ‰€æœ‰è§£æ³•
    this.solutions = Game24Logic.getAllSolutions(cardNumbers);
    
    // é‡ç½®çŠ¶æ€
    this.inputExpression = '';
    this.gameMessage = 'è¯·ä½¿ç”¨è¿™4å¼ ç‰Œçš„ç‚¹æ•°ï¼Œé€šè¿‡åŠ å‡ä¹˜é™¤è¿ç®—å¾—å‡º24';
    this.showMessage = true;
    this.isCorrect = false;
    this.gameFinished = false;
    this.playerJudgment = '';
  }
  
  // å¤„ç†è¾“å…¥è¡¨è¾¾å¼å˜åŒ–
  private onExpressionChange(value: string): void {
    this.inputExpression = value;
  }
  
  // ç©å®¶ç‚¹å‡»æ— è§£æŒ‰é’®
  markAsUnsolvable() {
    this.playerJudgment = 'unsolvable';
    
    // æ¸…é™¤å®šæ—¶å™¨
    if (this.timerId !== -1) {
      clearInterval(this.timerId);
      this.timerId = -1;
    }
    
    // æ£€æŸ¥ç©å®¶åˆ¤æ–­æ˜¯å¦æ­£ç¡®
    if (!this.hasSolution) {
      // å½“ç©å®¶åˆ¤æ–­æ­£ç¡®ä¸”é¢˜ç›®ç¡®å®æ— è§£æ—¶ï¼Œæ˜¾ç¤ºç±»ä¼¼æ­£ç¡®ç­”æ¡ˆçš„æç¤º
      this.gameMessage = `ğŸ‰ æ­å–œï¼åˆ¤æ–­æ­£ç¡®ã€‚è¿™ç»„ç‰Œç¡®å®æ— è§£ã€‚ç”¨æ—¶: ${this.currentTime}ç§’`;
      this.isCorrect = true;
    } else {
      // å½“ç©å®¶åˆ¤æ–­é”™è¯¯æ—¶ï¼Œæ˜¾ç¤ºé¢˜ç›®çš„è§£æ³•
      const firstSolution = this.solutions.length > 0 ? this.solutions[0] : "æ— è§£æ³•";
      this.gameMessage = `âŒ åˆ¤æ–­é”™è¯¯ï¼è¿™ç»„ç‰Œå…¶å®æœ‰è§£: ${firstSolution}`;
      this.isCorrect = false;
    }
    this.showMessage = true;
    this.gameFinished = true;
  }
  
  // æäº¤ç­”æ¡ˆ - æ–°æ€è·¯å®ç°
  submitAnswer() {
    // ç©å®¶æäº¤è¡¨è¾¾å¼ï¼Œè¡¨ç¤ºè®¤ä¸ºæœ‰è§£
    this.playerJudgment = 'solved';
    
    if (!this.inputExpression) {
      this.gameMessage = 'è¯·è¾“å…¥è¡¨è¾¾å¼';
      this.showMessage = true;
      return;
    }
    
    // ä½¿ç”¨æ–°çš„è§£ææ–¹æ³•éªŒè¯è¡¨è¾¾å¼
    const result = this.parseAndEvaluate(this.inputExpression, this.cards);
    
    if (!result.isValid) {
      this.gameMessage = result.message || 'è¡¨è¾¾å¼æ— æ•ˆ';
      this.showMessage = true;
      this.isCorrect = false;
      this.gameFinished = true;
      return;
    }
    
    // æ¸…é™¤å®šæ—¶å™¨
    if (this.timerId !== -1) {
      clearInterval(this.timerId);
      this.timerId = -1;
    }
    
    if (Math.abs(result.value! - 24) < 1e-6) {
      this.gameMessage = `ğŸ‰ æ­å–œï¼ç­”æ¡ˆæ­£ç¡®ã€‚${this.inputExpression} = ${result.value} ç”¨æ—¶: ${this.currentTime}ç§’`;
      this.showMessage = true;
      this.isCorrect = true;
      this.gameFinished = true;
    } else {
      this.gameMessage = `âŒ ç­”æ¡ˆé”™è¯¯ã€‚${this.inputExpression} = ${result.value} â‰  24`;
      this.showMessage = true;
      this.isCorrect = false;
      this.gameFinished = true;
    }
  }
  
  // è§£æå¹¶è®¡ç®—ç”¨æˆ·è¾“å…¥çš„è¡¨è¾¾å¼
  parseAndEvaluate(expression: string, cards: Card[]): SimpleEvaluationResult {
    try {
      // é¢„å¤„ç†è¡¨è¾¾å¼
      let processedExpr = expression.replace(/\s/g, ''); // ç§»é™¤ç©ºæ ¼
      
      // æ›¿æ¢ç‰¹æ®Šç¬¦å·
      processedExpr = processedExpr.replace(/Ã—/g, '*');
      processedExpr = processedExpr.replace(/Ã·/g, '/');
      processedExpr = processedExpr.replace(/âˆ’/g, '-');
      processedExpr = processedExpr.replace(/ï¹£/g, '-');
      processedExpr = processedExpr.replace(/Â·/g, '*');
      
      // æ£€æŸ¥æ˜¯å¦åŒ…å«éæ³•å­—ç¬¦
      if (!/^[\d+\-*/().]+$/.test(processedExpr)) {
        const result: SimpleEvaluationResult = { isValid: false, message: "è¡¨è¾¾å¼åŒ…å«éæ³•å­—ç¬¦" };
        return result;
      }
      
      // æå–æ•°å­—
      const numbers = this.extractNumbersFromExpression(processedExpr);
      
      // æ£€æŸ¥æ˜¯å¦æ­£å¥½æœ‰4ä¸ªæ•°å­—
      if (numbers.length !== 4) {
        const result: SimpleEvaluationResult = { isValid: false, message: `è¡¨è¾¾å¼åº”åŒ…å«4ä¸ªæ•°å­—ï¼Œä½†æ‰¾åˆ°äº†${numbers.length}ä¸ª` };
        return result;
      }
      
      // æ£€æŸ¥æ•°å­—æ˜¯å¦ä¸å¡ç‰ŒåŒ¹é…
      const cardValues = cards.map(card => card.getRankValue()).sort();
      const exprNumbers = [...numbers].sort();
      
      for (let i = 0; i < 4; i++) {
        if (exprNumbers[i] !== cardValues[i]) {
          const result: SimpleEvaluationResult = { isValid: false, message: `ä½¿ç”¨çš„æ•°å­—ä¸å¡ç‰Œä¸åŒ¹é…` };
          return result;
        }
      }
      
      // è®¡ç®—è¡¨è¾¾å¼ç»“æœ
      const value = this.evaluateExpression(processedExpr);
      
      const result: SimpleEvaluationResult = { isValid: true, value: value };
      return result;
    } catch (error) {
      const result: SimpleEvaluationResult = { 
        isValid: false, 
        message: "è¡¨è¾¾å¼æ ¼å¼é”™è¯¯: " + (error instanceof Error ? error.message : String(error)) 
      };
      return result;
    }
  }
  
  // ä»è¡¨è¾¾å¼ä¸­æå–æ•°å­—
  extractNumbersFromExpression(expression: string): number[] {
    const numbers: number[] = [];
    let i = 0;
    
    while (i < expression.length) {
      // è·³è¿‡æ“ä½œç¬¦å’Œæ‹¬å·
      if ('+-*/()'.includes(expression[i])) {
        i++;
        continue;
      }
      
      // æå–æ•°å­—
      if (/\d/.test(expression[i])) {
        let numStr = '';
        while (i < expression.length && /\d/.test(expression[i])) {
          numStr += expression[i];
          i++;
        }
        const num = parseInt(numStr, 10);
        if (num >= 1 && num <= 13) {
          numbers.push(num);
        }
      } else {
        i++;
      }
    }
    
    return numbers;
  }
  
  // è®¡ç®—è¡¨è¾¾å¼ç»“æœ - è‡ªå®šä¹‰è§£æå®ç°
  evaluateExpression(expression: string): number {
    // å…ˆéªŒè¯è¡¨è¾¾å¼æ ¼å¼
    if (!expression || typeof expression !== 'string') {
      throw new Error("æ— æ•ˆçš„è¡¨è¾¾å¼");
    }
    
    // ç¡®ä¿è¡¨è¾¾å¼åªåŒ…å«å…è®¸çš„å­—ç¬¦
    if (!/^[\d+\-*/().]+$/.test(expression)) {
      throw new Error("è¡¨è¾¾å¼åŒ…å«éæ³•å­—ç¬¦");
    }
    
    // éªŒè¯æ‹¬å·åŒ¹é…
    if (!this.checkParentheses(expression)) {
      throw new Error("æ‹¬å·ä¸åŒ¹é…");
    }
    
    try {
      // é€’å½’è®¡ç®—è¡¨è¾¾å¼
      const result: number = this.calculate(expression);
      return Math.round(result * 1000000) / 1000000;
    } catch (error) {
      throw new Error("è®¡ç®—é”™è¯¯: " + (error instanceof Error ? error.message : String(error)));
    }
  }
  
  // æ£€æŸ¥æ‹¬å·æ˜¯å¦åŒ¹é…
  checkParentheses(expression: string): boolean {
    let count: number = 0;
    for (let i: number = 0; i < expression.length; i++) {
      if (expression[i] === '(') {
        count++;
      } else if (expression[i] === ')') {
        count--;
        if (count < 0) {
          return false;
        }
      }
    }
    return count === 0;
  }
  
  // é€’å½’è®¡ç®—è¡¨è¾¾å¼
  calculate(expr: string): number {
    // ç§»é™¤ç©ºæ ¼
    expr = expr.replace(/\s/g, '');
    
    if (expr.length === 0) {
      throw new Error("ç©ºè¡¨è¾¾å¼");
    }
    
    // å¤„ç†æ‹¬å·
    while (expr.includes('(')) {
      const lastOpenParen: number = expr.lastIndexOf('(');
      const firstCloseParenAfter: number = expr.indexOf(')', lastOpenParen);
      
      if (firstCloseParenAfter === -1) {
        throw new Error("æ‹¬å·ä¸åŒ¹é…");
      }
      
      const innerExpr: string = expr.substring(lastOpenParen + 1, firstCloseParenAfter);
      const innerResult: number = this.calculate(innerExpr);
      expr = expr.substring(0, lastOpenParen) + innerResult.toString() + expr.substring(firstCloseParenAfter + 1);
    }
    
    // å¤„ç†ä¹˜æ³•å’Œé™¤æ³•
    while (expr.includes('*') || expr.includes('/')) {
      const mulIndex: number = expr.indexOf('*');
      const divIndex: number = expr.indexOf('/');
      
      let operatorIndex: number;
      let operator: string;
      
      if (mulIndex !== -1 && (divIndex === -1 || mulIndex < divIndex)) {
        operatorIndex = mulIndex;
        operator = '*';
      } else if (divIndex !== -1) {
        operatorIndex = divIndex;
        operator = '/';
      } else {
        break;
      }
      
      // è·å–æ“ä½œç¬¦å‰çš„æ•°å­—
      let leftStart: number = operatorIndex - 1;
      while (leftStart >= 0 && (/\d/.test(expr[leftStart]) || expr[leftStart] === '.' || expr[leftStart] === '-')) {
        if (expr[leftStart] === '-' && leftStart > 0 && !'0123456789.'.includes(expr[leftStart - 1])) {
          break;
        }
        leftStart--;
      }
      leftStart++;
      
      // è·å–æ“ä½œç¬¦åçš„æ•°å­—
      let rightEnd: number = operatorIndex + 1;
      if (rightEnd < expr.length && expr[rightEnd] === '-') {
        rightEnd++;
      }
      while (rightEnd < expr.length && (/\d/.test(expr[rightEnd]) || expr[rightEnd] === '.')) {
        rightEnd++;
      }
      
      const leftNum: number = parseFloat(expr.substring(leftStart, operatorIndex));
      const rightNum: number = parseFloat(expr.substring(operatorIndex + 1, rightEnd));
      
      if (isNaN(leftNum) || isNaN(rightNum)) {
        throw new Error("æ— æ•ˆæ•°å­—");
      }
      
      let result: number;
      if (operator === '*') {
        result = leftNum * rightNum;
      } else {
        if (Math.abs(rightNum) < 1e-10) {
          throw new Error("é™¤æ•°ä¸èƒ½ä¸ºé›¶");
        }
        result = leftNum / rightNum;
      }
      
      expr = expr.substring(0, leftStart) + result.toString() + expr.substring(rightEnd);
    }
    
    // å¤„ç†åŠ æ³•å’Œå‡æ³•
    // å…ˆå¤„ç†ç¬¬ä¸€ä¸ªæ•°å­—å¯èƒ½ä¸ºè´Ÿæ•°çš„æƒ…å†µ
    let startIndex: number = 0;
    if (expr[0] === '-') {
      startIndex = 1;
    }
    
    while (expr.includes('+') || expr.indexOf('-', startIndex) !== -1) {
      const addIndex: number = expr.indexOf('+', startIndex);
      const subIndex: number = expr.indexOf('-', startIndex);
      
      let operatorIndex: number;
      let operator: string;
      
      if (addIndex !== -1 && (subIndex === -1 || addIndex < subIndex)) {
        operatorIndex = addIndex;
        operator = '+';
      } else if (subIndex !== -1 && subIndex >= startIndex) {
        operatorIndex = subIndex;
        operator = '-';
      } else {
        break;
      }
      
      // è·å–æ“ä½œç¬¦å‰çš„æ•°å­—
      let leftStart: number = operatorIndex - 1;
      while (leftStart >= 0 && (/\d/.test(expr[leftStart]) || expr[leftStart] === '.' || expr[leftStart] === '-')) {
        if (expr[leftStart] === '-' && leftStart > 0 && !'0123456789.'.includes(expr[leftStart - 1])) {
          break;
        }
        leftStart--;
      }
      leftStart++;
      
      // è·å–æ“ä½œç¬¦åçš„æ•°å­—
      let rightEnd: number = operatorIndex + 1;
      if (rightEnd < expr.length && expr[rightEnd] === '-') {
        rightEnd++;
      }
      while (rightEnd < expr.length && (/\d/.test(expr[rightEnd]) || expr[rightEnd] === '.')) {
        rightEnd++;
      }
      
      const leftNum: number = parseFloat(expr.substring(leftStart, operatorIndex));
      const rightNum: number = parseFloat(expr.substring(operatorIndex + 1, rightEnd));
      
      if (isNaN(leftNum) || isNaN(rightNum)) {
        throw new Error("æ— æ•ˆæ•°å­—");
      }
      
      let result: number;
      if (operator === '+') {
        result = leftNum + rightNum;
      } else {
        result = leftNum - rightNum;
      }
      
      expr = expr.substring(0, leftStart) + result.toString() + expr.substring(rightEnd);
    }
    
    const finalResult: number = parseFloat(expr);
    if (isNaN(finalResult)) {
      throw new Error("è®¡ç®—ç»“æœæ— æ•ˆ");
    }
    
    return finalResult;
  }
  
  // æ˜¾ç¤ºè§£æ³•å¼¹çª—
  showSolutionsDialog() {
    let content = '';
    if (this.solutions.length > 0) {
      // æ˜¾ç¤ºå‰3ä¸ªè§£æ³•
      const displaySolutions = this.solutions.slice(0, 3);
      content = displaySolutions.join('\n');
      
      // å¦‚æœè¿˜æœ‰æ›´å¤šè§£æ³•ï¼Œæ·»åŠ æç¤º
      if (this.solutions.length > 3) {
        content += `\n\nè¿˜æœ‰${this.solutions.length - 3}ä¸ªè§£æ³•...`;
      }
    } else {
      content = 'è¿™é“é¢˜æ— è§£';
    }
    
    promptAction.showDialog({
      title: 'å‚è€ƒè§£æ³•',
      message: content,
      buttons: [
        {
          text: 'ç¡®å®š',
          color: '#007DFF'
        }
      ]
    });
  }

  build() {
    Column() {
      // æ ‡é¢˜åŒºåŸŸ
      Column() {
        Text('â™ ï¸ 24ç‚¹æ¸¸æˆ ğŸƒ')
          .fontSize(32)
          .fontWeight(FontWeight.Bold)
          .textAlign(TextAlign.Center)
          .fontColor('#1a1a1a')
          .margin({ top: 30 })
        
        Text('ä½¿ç”¨4å¼ ç‰Œé€šè¿‡è¿ç®—å¾—åˆ°24')
          .fontSize(16)
          .fontColor('#666666')
          .margin({ top: 8 })
        
        // æ—¶é—´æ˜¾ç¤º
        Row() {
          Text('â±')
            .fontSize(18)
          Text(`${this.currentTime.toString().padStart(3, '0')}s`)
            .fontSize(18)
            .fontWeight(FontWeight.Medium)
            .fontColor('#333333')
            .margin({ left: 10 })
        }
        .width(200)
        .justifyContent(FlexAlign.Center)
        .padding({ left: 20, right: 20, top: 10, bottom: 10 })
        .backgroundColor('#FFFFFF')
        .borderRadius(18)
        .shadow({
          radius: 6,
          color: '#333333',
          offsetX: 2,
          offsetY: 2
        })
        .margin({ top: 15, bottom: 5 })
        .alignSelf(ItemAlign.Center)
      }
      .margin({ bottom: 30 })

      // å¡ç‰Œæ˜¾ç¤ºåŒºåŸŸ
      Row() {
        ForEach(this.cards, (card: Card, index: number) => {
          Image($r('app.media.' + card.getResourceName()))
            .width(80)
            .height(110)
            .margin({ left: 5, right: 5 })
            .borderRadius(8)
            .shadow({
              radius: 6,
              color: '#333333',
              offsetX: 2,
              offsetY: 2
            })
        }, (item: Card) => item.getResourceName())
      }
      .margin({ top: 20, bottom: 30 })
      .alignItems(VerticalAlign.Center)
      
      // è¾“å…¥åŒºåŸŸ
      Column() {
        Text('è¯·è¾“å…¥è¿ç®—è¡¨è¾¾å¼:')
          .fontSize(18)
          .margin({ bottom: 15 })
          .fontColor('#333333')
        
        // æç¤ºä¿¡æ¯
        Row() {
          Text(this.gameMessage)
            .fontSize(16)
            .fontColor(this.isCorrect ? '#2e7d32' : '#c62828')
            .textAlign(TextAlign.Center)
            .width('80%')
            .padding(15)
            .backgroundColor('#FFFFFF')
            .borderRadius(12)
            .shadow({
              radius: 4,
              color: '#333333',
              offsetX: 1,
              offsetY: 1
            })
            .visibility(this.showMessage ? Visibility.Visible : Visibility.Hidden)
        }
        .width('100%')
        .justifyContent(FlexAlign.Center)
        .margin({ bottom: 20 })
        
        TextInput({ placeholder: 'ä¾‹å¦‚: (5-1)*(6/2)', text: this.inputExpression })
          .onChange((value: string) => this.onExpressionChange(value))
          .width('80%')
          .height(50)
          .margin({ bottom: 30, top: 10 })
          .enabled(!this.gameFinished)
          .backgroundColor('#FFFFFF')
          .borderRadius(12)
          .shadow({
            radius: 4,
            color: '#333333',
            offsetX: 1,
            offsetY: 1
          })
      }
      .width('100%')
      .alignItems(HorizontalAlign.Center)
      
      // æŒ‰é’®åŒºåŸŸ
      Column() {
        Row() {
          Button('é‡æ–°å¼€å§‹ ğŸ”„')
            .width(140)
            .height(45)
            .margin({ right: 15 })
            .fontSize(16)
            .backgroundColor('#FFFFFF')
            .fontColor('#333333')
            .borderRadius(12)
            .shadow({
              radius: 4,
              color: '#333333',
              offsetX: 1,
              offsetY: 1
            })
            .onClick(() => {
              this.startNewGame();
            })
          
          Button('æ— è§£ âŒ')
            .width(140)
            .height(45)
            .fontSize(16)
            .backgroundColor('#FFFFFF')
            .fontColor('#333333')
            .borderRadius(12)
            .shadow({
              radius: 4,
              color: '#333333',
              offsetX: 1,
              offsetY: 1
            })
            .enabled(!this.gameFinished)
            .onClick(() => {
              this.markAsUnsolvable();
            })
        }
        .margin({ bottom: 15 })
        .justifyContent(FlexAlign.Center)
        
        // æŸ¥çœ‹ç­”æ¡ˆæŒ‰é’®ï¼ˆä»…åœ¨æ¸¸æˆç»“æŸåæ˜¾ç¤ºï¼‰
        if (this.gameFinished) {
          Button('æŸ¥çœ‹ç­”æ¡ˆ ğŸ‘€')
            .width('80%')
            .height(45)
            .fontSize(16)
            .backgroundColor('#FFFFFF')
            .fontColor('#333333')
            .borderRadius(12)
            .shadow({
              radius: 4,
              color: '#333333',
              offsetX: 1,
              offsetY: 1
            })
            .margin({ bottom: 15 })
            .onClick(() => {
              this.showSolutionsDialog();
            })
        }
        
        // æäº¤æŒ‰é’®ï¼ˆä»…åœ¨æ¸¸æˆæœªç»“æŸä¸”ç©å®¶æœªåˆ¤æ–­æ— è§£æ—¶æ˜¾ç¤ºï¼‰
        if (!this.gameFinished) {
          Button('æäº¤ç­”æ¡ˆ âœ…')
            .width('80%')
            .height(45)
            .fontSize(16)
            .backgroundColor('#FFFFFF')
            .fontColor('#333333')
            .borderRadius(12)
            .shadow({
              radius: 4,
              color: '#333333',
              offsetX: 1,
              offsetY: 1
            })
            .enabled(!this.gameFinished)
            .onClick(() => {
              this.submitAnswer();
            })
            .margin({ bottom: 15 })
        }
      }
      .width('100%')
      .alignItems(HorizontalAlign.Center)
      .layoutWeight(1)
      .justifyContent(FlexAlign.End)
      .padding({ bottom: 30 })
      
      // åº•éƒ¨ä¿¡æ¯åŒºåŸŸ
      Column() {
        Text('24ç‚¹æ¸¸æˆè€ƒéªŒä½ çš„æ•°å­¦è¿ç®—èƒ½åŠ›')
          .fontSize(12)
          .fontColor('#999999')
          .margin({ bottom: 8 })

        Text('ğŸ§  æ•°å­¦è¿ç®— | â±ï¸ é€»è¾‘æŒ‘æˆ˜')
          .fontSize(11)
          .fontColor('#bbbbbb')
          .margin({ bottom: 4 })

        Text('åˆ¶ä½œäººï¼šNisson_CX')
          .fontSize(11)
          .fontColor('#cccccc')
          .margin({ bottom: 20 })
      }
      .width('100%')
      .alignItems(HorizontalAlign.Center)
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#f0f0f0')
    .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])
  }
}